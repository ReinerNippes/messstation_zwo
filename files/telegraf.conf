[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"

# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.  Increasing this value
  ## allows for longer periods of output downtime without dropping metrics at the
  ## cost of higher maximum memory usage.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Collection offset is used to shift the collection by the given amount.
  ## This can be be used to avoid many plugins querying constraint devices
  ## at the same time by manually scheduling them in time.
  # collection_offset = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## Collected metrics are rounded to the precision specified. Precision is
  ## specified as an interval with an integer + unit (e.g. 0s, 10ms, 2us, 4s).
  ## Valid time units are "ns", "us" (or "Âµs"), "ms", "s".
  ##
  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s:
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ##
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  precision = "0s"

  ## Log at debug level.
  # debug = false
  ## Log only error level messages.
  # quiet = false

  ## Log format controls the way messages are logged and can be one of "text",
  ## "structured" or, on Windows, "eventlog".
  # logformat = "text"

  ## Message key for structured logs, to override the default of "msg".
  ## Ignored if `logformat` is not "structured".
  # structured_log_message_key = "message"

  ## Name of the file to be logged to or stderr if unset or empty. This
  ## setting is ignored for the "eventlog" format.
  # logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.  Logs are rotated only when
  ## written to, if there is no log activity rotation may be delayed.
  # logfile_rotation_interval = "0h"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Pick a timezone to use when logging or type 'local' for local time.
  ## Example: America/Chicago
  # log_with_timezone = ""

  ## Override default hostname, if empty use os.Hostname()
  # hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  # omit_hostname = false

  ## Method of translating SNMP objects. Can be "netsnmp" (deprecated) which
  ## translates by calling external programs snmptranslate and snmptable,
  ## or "gosmi" which translates using the built-in gosmi library.
  # snmp_translator = "netsnmp"

  ## Name of the file to load the state of plugins from and store the state to.
  ## If uncommented and not empty, this file will be used to save the state of
  ## stateful plugins on termination of Telegraf. If the file exists on start,
  ## the state in the file will be restored for the plugins.
  # statefile = ""

  ## Flag to skip running processors after aggregators
  ## By default, processors are run a second time after aggregators. Changing
  ## this setting to true will skip the second run of processors.
  # skip_processors_after_aggregators = false

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# # Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
## The full HTTP or UDP URL for your InfluxDB instance.
##
## Multiple URLs can be specified for a single cluster, only ONE of the
## urls will be written to each interval.
# urls = ["unix:///var/run/influxdb.sock"]
# urls = ["udp://127.0.0.1:8089"]
urls = ["http://influxdb:8086"]

## Local address to bind when connecting to the server
## If empty or not set, the local address is automatically chosen.
# local_address = ""

## The target database for metrics; will be created as needed.
## For UDP url endpoint database needs to be configured on server side.
database = "local_monitoring"

## The value of this tag will be used to determine the database.  If this
## tag is not set the 'database' option is used as the default.
# database_tag = ""

## If true, the 'database_tag' will not be included in the written metric.
# exclude_database_tag = false

## If true, no CREATE DATABASE queries will be sent.  Set to true when using
## Telegraf with a user without permissions to create databases or when the
## database already exists.
skip_database_creation = false

## Name of existing retention policy to write to.  Empty string writes to
## the default retention policy.  Only takes effect when using HTTP.
# retention_policy = ""

## The value of this tag will be used to determine the retention policy.  If this
## tag is not set the 'retention_policy' option is used as the default.
# retention_policy_tag = ""

## If true, the 'retention_policy_tag' will not be included in the written metric.
# exclude_retention_policy_tag = false

## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
## Only takes effect when using HTTP.
# write_consistency = "any"

## Timeout for HTTP messages.
# timeout = "5s"

## HTTP Basic Auth
username = "dfld"
password = "dfld"

## HTTP User-Agent
user_agent = "telegraf"

## UDP payload size is the maximum packet size to send.
# udp_payload = "512B"

## Optional TLS Config for use on HTTP connections.
# tls_ca = "/etc/telegraf/ca.pem"
# tls_cert = "/etc/telegraf/cert.pem"
# tls_key = "/etc/telegraf/key.pem"
## Use TLS but skip chain & host verification
insecure_skip_verify = true

## HTTP Proxy override, if unset values the standard proxy environment
## variables are consulted to determine which proxy, if any, should be used.
# http_proxy = "http://corporate.proxy:3128"

## Additional HTTP headers
# http_headers = {"X-Special-Header" = "Special-Value"}

## HTTP Content-Encoding for write request body, can be set to "gzip" to
## compress body or "identity" to apply no encoding.
# content_encoding = "gzip"

## When true, Telegraf will output unsigned integers as unsigned values,
## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
## integer values.  Enabling this option will result in field type errors if
## existing data has been written.
# influx_uint_support = false

## When true, Telegraf will omit the timestamp on data to allow InfluxDB
## to set the timestamp of the data during ingestion. This is generally NOT
## what you want as it can lead to data points captured at different times
## getting omitted due to similar data.
# influx_omit_timestamp = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################


# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states
  ## NOTE: The resulting 'time_active' field INCLUDES 'iowait'!
  report_active = false
  ## If true and the info is available then add core_id and physical_id tags
  core_tags = false


# Read metrics about disk usage by mount point
[[inputs.disk]]
  ## By default stats will be gathered for all mount points.
  ## Set mount_points will restrict the stats to only the specified mount points.
  # mount_points = ["/"]

  ## Ignore mount points by filesystem type.
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

  ## Ignore mount points by mount options.
  ## The 'mount' command reports options of all mounts in parathesis.
  ## Bind mounts can be ignored with the special 'bind' option.
  # ignore_mount_opts = []


# Read metrics about disk IO by device
[[inputs.diskio]]
  ## Devices to collect stats for
  ## Wildcards are supported except for disk synonyms like '/dev/disk/by-id'.
  ## ex. devices = ["sda", "sdb", "vd*", "/dev/disk/by-id/nvme-eui.00123deadc0de123"]
devices = ["*"]

  ## Skip gathering of the disk's serial numbers.
skip_serial_number = true

  ## Device metadata tags to add on systems supporting it (Linux only)
  ## Use 'udevadm info -q property -n <device>' to get a list of properties.
  ## Note: Most, but not all, udev properties can be accessed this way. Properties
  ## that are currently inaccessible include DEVTYPE, DEVNAME, and DEVPATH.
  # device_tags = ["ID_FS_TYPE", "ID_FS_USAGE"]

  ## Using the same metadata source as device_tags, you can also customize the
  ## name of the device via templates.
  ## The 'name_templates' parameter is a list of templates to try and apply to
  ## the device. The template may contain variables in the form of '$PROPERTY' or
  ## '${PROPERTY}'. The first template which does not contain any variables not
  ## present for the device is used as the device name tag.
  ## The typical use case is for LVM volumes, to get the VG/LV name instead of
  ## the near-meaningless DM-0 name.
  name_templates = ["$ID_FS_LABEL","$DM_VG_NAME/$DM_LV_NAME"]


# Plugin to collect various Linux kernel statistics.
# This plugin ONLY supports Linux
[[inputs.kernel]]
  ## Additional gather options
  ## Possible options include:
  ## * ksm - kernel same-page merging
  ## * psi - pressure stall information
  # collect = []


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Get the number of processes and group them by status
# This plugin ONLY supports non-Windows
[[inputs.processes]]
  ## Use sudo to run ps command on *BSD systems. Linux systems will read
  ## /proc, so this does not apply there.
  # use_sudo = false


# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration


# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration


# # Read Apache status information (mod_status)
# [[inputs.apache]]
#   ## An array of URLs to gather from, must be directed at the machine
#   ## readable version of the mod_status page including the auto query string.
#   ## Default is "http://localhost/server-status?auto".
#   urls = ["http://localhost/server-status?auto"]
#
#   ## Credentials for basic HTTP authentication.
#   # username = "myuser"
#   # password = "mypassword"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics about docker containers
# [[inputs.docker]]
#   ## Docker Endpoint
#   ##   To use TCP, set endpoint = "tcp://[ip]:[port]"
#   ##   To use environment variables (ie, docker-machine), set endpoint = "ENV"
#   endpoint = "unix:///var/run/docker.sock"
#
#   ## Set to true to collect Swarm metrics(desired_replicas, running_replicas)
#   ## Note: configure this in one of the manager nodes in a Swarm cluster.
#   ## configuring in multiple Swarm managers results in duplication of metrics.
#   gather_services = false
#
#   ## Only collect metrics for these containers. Values will be appended to
#   ## container_name_include.
#   ## Deprecated (1.4.0), use container_name_include
#   container_names = []
#
#   ## Set the source tag for the metrics to the container ID hostname, eg first 12 chars
#   source_tag = false
#
#   ## Containers to include and exclude. Collect all if empty. Globs accepted.
#   container_name_include = []
#   container_name_exclude = []
#
#   ## Container states to include and exclude. Globs accepted.
#   ## When empty only containers in the "running" state will be captured.
#   ## example: container_state_include = ["created", "restarting", "running", "removing", "paused", "exited", "dead"]
#   ## example: container_state_exclude = ["created", "restarting", "running", "removing", "paused", "exited", "dead"]
#   # container_state_include = []
#   # container_state_exclude = []
#
#   ## Objects to include for disk usage query
#   ## Allowed values are "container", "image", "volume"
#   ## When empty disk usage is excluded
#   storage_objects = []
#
#   ## Timeout for docker list, info, and stats commands
#   timeout = "5s"
#
#   ## Specifies for which classes a per-device metric should be issued
#   ## Possible values are 'cpu' (cpu0, cpu1, ...), 'blkio' (8:0, 8:1, ...) and 'network' (eth0, eth1, ...)
#   ## Please note that this setting has no effect if 'perdevice' is set to 'true'
#   # perdevice_include = ["cpu"]
#
#   ## Specifies for which classes a total metric should be issued. Total is an aggregated of the 'perdevice' values.
#   ## Possible values are 'cpu', 'blkio' and 'network'
#   ## Total 'cpu' is reported directly by Docker daemon, and 'network' and 'blkio' totals are aggregated by this plugin.
#   ## Please note that this setting has no effect if 'total' is set to 'false'
#   # total_include = ["cpu", "blkio", "network"]
#
#   ## docker labels to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all labels as tags
#   docker_label_include = []
#   docker_label_exclude = []
#
#   ## Which environment variables should we use as a tag
#   tag_env = ["JAVA_HOME", "HEAP_SIZE"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Returns ethtool statistics for given interfaces
# # This plugin ONLY supports Linux
# [[inputs.ethtool]]
#   ## List of interfaces to pull metrics for
#   # interface_include = ["eth0"]
#
#   ## List of interfaces to ignore when pulling metrics.
#   # interface_exclude = ["eth1"]
#
#   ## Plugin behavior for downed interfaces
#   ## Available choices:
#   ##   - expose: collect & report metrics for down interfaces
#   ##   - skip: ignore interfaces that are marked down
#   # down_interfaces = "expose"
#
#   ## Reading statistics from interfaces in additional namespaces is also
#   ## supported, so long as the namespaces are named (have a symlink in
#   ## /var/run/netns). The telegraf process will also need the CAP_SYS_ADMIN
#   ## permission.
#   ## By default, only the current namespace will be used. For additional
#   ## namespace support, at least one of `namespace_include` and
#   ## `namespace_exclude` must be provided.
#   ## To include all namespaces, set `namespace_include` to `["*"]`.
#   ## The initial namespace (if anonymous) can be specified with the empty
#   ## string ("").
#
#   ## List of namespaces to pull metrics for
#   # namespace_include = []
#
#   ## List of namespace to ignore when pulling metrics.
#   # namespace_exclude = []
#
#   ## Some drivers declare statistics with extra whitespace, different spacing,
#   ## and mix cases. This list, when enabled, can be used to clean the keys.
#   ## Here are the current possible normalizations:
#   ##  * snakecase: converts fooBarBaz to foo_bar_baz
#   ##  * trim: removes leading and trailing whitespace
#   ##  * lower: changes all capitalized letters to lowercase
#   ##  * underscore: replaces spaces with underscores
#   # normalize_keys = ["snakecase", "trim", "lower", "underscore"]


# # Parse a complete file each interval
# [[inputs.file]]
#   ## Files to parse each interval.  Accept standard unix glob matching rules,
#   ## as well as ** to match recursive files and directories.
#   files = ["/tmp/metrics.out"]
#
#   ## Character encoding to use when interpreting the file contents.  Invalid
#   ## characters are replaced using the unicode replacement character.  When set
#   ## to the empty string the data is not decoded to text.
#   ##   ex: character_encoding = "utf-8"
#   ##       character_encoding = "utf-16le"
#   ##       character_encoding = "utf-16be"
#   ##       character_encoding = ""
#   # character_encoding = ""
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#
#   ## Please use caution when using the following options: when file name
#   ## variation is high, this can increase the cardinality significantly. Read
#   ## more about cardinality here:
#   ## https://docs.influxdata.com/influxdb/cloud/reference/glossary/#series-cardinality
#
#   ## Name of tag to store the name of the file. Disabled if not set.
#   # file_tag = ""
#
#   ## Name of tag to store the absolute path and name of the file. Disabled if
#   ## not set.
#   # file_path_tag = ""


# # Count files in a directory
# [[inputs.filecount]]
#   ## Directories to gather stats about.
#   ## This accept standard unit glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   /var/log/**    -> recursively find all directories in /var/log and count files in each directories
#   ##   /var/log/*/*   -> find all directories with a parent dir in /var/log and count files in each directories
#   ##   /var/log       -> count all files in /var/log and all of its subdirectories
#   directories = ["/var/cache/apt", "/tmp"]
#
#   ## Only count files that match the name pattern. Defaults to "*".
#   name = "*"
#
#   ## Count files in subdirectories. Defaults to true.
#   recursive = true
#
#   ## Only count regular files. Defaults to true.
#   regular_only = true
#
#   ## Follow all symlinks while walking the directory tree. Defaults to false.
#   follow_symlinks = false
#
#   ## Only count files that are at least this size. If size is
#   ## a negative number, only count files that are smaller than the
#   ## absolute value of size. Acceptable units are B, KiB, MiB, KB, ...
#   ## Without quotes and units, interpreted as size in bytes.
#   size = "0B"
#
#   ## Only count files that have not been touched for at least this
#   ## duration. If mtime is negative, only count files that have been
#   ## touched in this duration. Defaults to "0s".
#   mtime = "0s"


# # Read stats about given file(s)
# [[inputs.filestat]]
#   ## Files to gather stats about.
#   ## These accept standard unix glob matching rules, but with the addition of
#   ## ** as a "super asterisk". See https://github.com/gobwas/glob.
#   files = ["/etc/telegraf/telegraf.conf", "/var/log/**.log"]
#
#   ## If true, read the entire file and calculate an md5 checksum.
#   md5 = false


# # Read real time temps from fireboard.io servers
# [[inputs.fireboard]]
#   ## Specify auth token for your account
#   auth_token = "invalidAuthToken"
#   ## You can override the fireboard server URL if necessary
#   # url = https://fireboard.io/api/v1/devices.json
#   ## You can set a different http_timeout if you need to
#   ## You should set a string using an number and time indicator
#   ## for example "12s" for 12 seconds.
#   # http_timeout = "4s"


# # Monitor disks' temperatures using hddtemp
# [[inputs.hddtemp]]
#   ## By default, telegraf gathers temps data from all disks detected by the
#   ## hddtemp.
#   ##
#   ## Only collect temps from the selected disks.
#   ##
#   ## A * as the device name will return the temperature values of all disks.
#   ##
#   # address = "127.0.0.1:7634"
#   # devices = ["sda", "*"]


# # HTTP/HTTPS request given an address a method and a timeout
# [[inputs.http_response]]
#   ## List of urls to query.
#   # urls = ["http://localhost"]
#
#   ## Set http_proxy.
#   ## Telegraf uses the system wide proxy settings if it's is not set.
#   # http_proxy = "http://localhost:8888"
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## HTTP Request Method
#   # method = "GET"
#
#   ## Whether to follow redirects from the server (defaults to false)
#   # follow_redirects = false
#
#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional HTTP Request Body
#   # body = '''
#   # {'fake':'data'}
#   # '''
#
#   ## Optional HTTP Request Body Form
#   ## Key value pairs to encode and set at URL form. Can be used with the POST
#   ## method + application/x-www-form-urlencoded content type to replicate the
#   ## POSTFORM method.
#   # body_form = { "key": "value" }
#
#   ## Optional name of the field that will contain the body of the response.
#   ## By default it is set to an empty String indicating that the body's
#   ## content won't be added
#   # response_body_field = ''
#
#   ## Maximum allowed HTTP response body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   ## If the response body size exceeds this limit a "body_read_error" will
#   ## be raised.
#   # response_body_max_size = "32MiB"
#
#   ## Optional substring or regex match in body of the response (case sensitive)
#   # response_string_match = "\"service_status\": \"up\""
#   # response_string_match = "ok"
#   # response_string_match = "\".*_status\".?:.?\"up\""
#
#   ## Expected response status code.
#   ## The status code of the response is compared to this value. If they match,
#   ## the field "response_status_code_match" will be 1, otherwise it will be 0.
#   ## If the expected status code is 0, the check is disabled and the field
#   ## won't be added.
#   # response_status_code = 0
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#   ## Use the given name as the SNI server name on each URL
#   # tls_server_name = ""
#   ## TLS renegotiation method, choose from "never", "once", "freely"
#   # tls_renegotiation_method = "never"
#
#   ## HTTP Request Headers (all values must be strings)
#   # [inputs.http_response.headers]
#   #   Host = "github.com"
#
#   ## Optional setting to map response http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will
#   ## be added. If multiple instances of the http header are present, only the
#   ## first value will be used.
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## Interface to use when dialing an address
#   # interface = "eth0"
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## cookie_auth_renewal not set or set to "0" will auth once and never renew the cookie
#   # cookie_auth_renewal = "5m"


# # Monitors internet speed using speedtest.net service
# [[inputs.internet_speed]]
#   ## This plugin downloads many MB of data each time it is run. As such
#   ## consider setting a higher interval for this plugin to reduce the
#   ## demand on your internet connection.
#   # interval = "60m"
#
#   ## Enable to reduce memory usage
#   # memory_saving_mode = false
#
#   ## Caches the closest server location
#   # cache = false
#
#   ## Number of concurrent connections
#   ## By default or set to zero, the number of CPU cores is used. Use this to
#   ## reduce the impact on system performance or to increase the connections on
#   ## faster connections to ensure the fastest speed.
#   # connections = 0
#
#   ## Test mode
#   ## By default, a single sever is used for testing. This may work for most,
#   ## however, setting to "multi" will reach out to multiple servers in an
#   ## attempt to get closer to ideal internet speeds.
#   ## And "multi" will use all available servers to calculate average packet loss.
#   # test_mode = "single"
#
#   ## Server ID exclude filter
#   ## Allows the user to exclude or include specific server IDs received by
#   ## speedtest-go. Values in the exclude option will be skipped over. Values in
#   ## the include option are the only options that will be picked from.
#   ##
#   ## See the list of servers speedtest-go will return at:
#   ##     https://www.speedtest.net/api/js/servers?engine=js&limit=10
#   ##
#   # server_id_exclude = []
#   # server_id_include = []


# # Gather packets and bytes throughput from iptables
# # This plugin ONLY supports Linux
# [[inputs.iptables]]
#   ## iptables require root access on most systems.
#   ## Setting 'use_sudo' to true will make use of sudo to run iptables.
#   ## Users must configure sudo to allow telegraf user to run iptables with
#   ## no password.
#   ## iptables can be restricted to only list command "iptables -nvL".
#   # use_sudo = false
#
#   ## Setting 'use_lock' to true runs iptables with the "-w" option.
#   ## Adjust your sudo settings appropriately if using this option
#   ## ("iptables -w 5 -nvl")
#   # use_lock = false
#
#   ## Define an alternate executable, such as "ip6tables". Default is "iptables".
#   # binary = "ip6tables"
#   ## defines the table to monitor:
#   table = "filter"
#
#   ## defines the chains to monitor.
#   ## NOTE: iptables rules without a comment will not be monitored.
#   ## Read the plugin documentation for more information.
#   chains = [ "INPUT" ]


# # Provides Linux CPU metrics
# # This plugin ONLY supports Linux
# [[inputs.linux_cpu]]
#   ## Path for sysfs filesystem.
#   ## See https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt
#   ## Defaults:
#   # host_sys = "/sys"
#
#   ## CPU metrics collected by the plugin.
#   ## Supported options:
#   ## "cpufreq", "thermal"
#   ## Defaults:
#   # metrics = ["cpufreq"]


# # Read metrics about LVM physical volumes, volume groups, logical volumes.
# [[inputs.lvm]]
#   ## Use sudo to run LVM commands
#   use_sudo = false
#
#   ## The default location of the pvs binary can be overridden with:
#   #pvs_binary = "/usr/sbin/pvs"
#
#   ## The default location of the vgs binary can be overridden with:
#   #vgs_binary = "/usr/sbin/vgs"
#
#   ## The default location of the lvs binary can be overridden with:
#   #lvs_binary = "/usr/sbin/lvs"


# # Gather metrics about network interfaces
# [[inputs.net]]
#   ## By default, telegraf gathers stats from any up interface (excluding loopback)
#   ## Setting interfaces will tell it to gather these explicit interfaces,
#   ## regardless of status. When specifying an interface, glob-style
#   ## patterns are also supported.
#   # interfaces = ["eth*", "enp0s[0-1]", "lo"]
#
#   ## On linux systems telegraf also collects protocol stats.
#   ## Setting ignore_protocol_stats to true will skip reporting of protocol metrics.
#   ##
#   ## DEPRECATION NOTICE: A value of 'false' is deprecated and discouraged!
#   ##                     Please set this to `true` and use the 'inputs.nstat'
#   ##                     plugin instead.
#   # ignore_protocol_stats = false


# # Collect response time of a TCP or UDP connection
# [[inputs.net_response]]
#   ## Protocol, must be "tcp" or "udp"
#   ## NOTE: because the "udp" protocol does not respond to requests, it requires
#   ## a send/expect string pair (see below).
#   protocol = "tcp"
#   ## Server address (default localhost)
#   address = "localhost:80"
#
#   ## Set timeout
#   # timeout = "1s"
#
#   ## Set read timeout (only used if expecting a response)
#   # read_timeout = "1s"
#
#   ## The following options are required for UDP checks. For TCP, they are
#   ## optional. The plugin will send the given string to the server and then
#   ## expect to receive the given 'expect' string back.
#   ## string sent to the server
#   # send = "ssh"
#   ## expected string in answer
#   # expect = "ssh"
#
#   ## Uncomment to remove deprecated fields; recommended for new deploys
#   # fieldexclude = ["result_type", "string_found"]


# # Read TCP metrics such as established, time wait and sockets counts.
# [[inputs.netstat]]
#   # no configuration


# # Read Nginx's basic status information (ngx_http_stub_status_module)
# [[inputs.nginx]]
#   ## An array of Nginx stub_status URI to gather stats.
#   urls = ["http://localhost/server_status"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## HTTP response timeout (default: 5s)
#   response_timeout = "5s"


# # Read Nginx Plus' advanced status information
# [[inputs.nginx_plus]]
#   ## An array of Nginx status URIs to gather stats.
#   urls = ["http://localhost/status"]
#
#   # HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx Plus API advanced status information
# [[inputs.nginx_plus_api]]
#   ## An array of Nginx API URIs to gather stats.
#   urls = ["http://localhost/api"]
#   # Nginx API version, default: 3
#   # api_version = 3
#
#   # HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx virtual host traffic status module information (nginx-module-sts)
# [[inputs.nginx_sts]]
#   ## An array of ngx_http_status_module or status URI to gather stats.
#   urls = ["http://localhost/status"]
#
#   ## HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read nginx_upstream_check module status information (https://github.com/yaoweibin/nginx_upstream_check_module)
# [[inputs.nginx_upstream_check]]
#   ## An URL where Nginx Upstream check module is enabled
#   ## It should be set to return a JSON formatted response
#   url = "http://127.0.0.1/status?format=json"
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## Override HTTP "Host" header
#   # host_header = "check.example.com"
#
#   ## Timeout for HTTP requests
#   timeout = "5s"
#
#   ## Optional HTTP Basic Auth credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx virtual host traffic status module information (nginx-module-vts)
# [[inputs.nginx_vts]]
#   ## An array of ngx_http_status_module or status URI to gather stats.
#   urls = ["http://localhost/status"]
#
#   ## HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Get standard NTP query metrics, requires ntpq executable.
# [[inputs.ntpq]]
#   ## Servers to query with ntpq.
#   ## If no server is given, the local machine is queried.
#   # servers = []
#
#   ## If false, set the -n ntpq flag. Can reduce metric gather time.
#   ## DEPRECATED since 1.24.0: add '-n' to 'options' instead to skip DNS lookup
#   # dns_lookup = true
#
#   ## Options to pass to the ntpq command.
#   # options = "-p"
#
#   ## Output format for the 'reach' field.
#   ## Available values are
#   ##   octal   --  output as is in octal representation e.g. 377 (default)
#   ##   decimal --  convert value to decimal representation e.g. 371 -> 249
#   ##   count   --  count the number of bits in the value. This represents
#   ##               the number of successful reaches, e.g. 37 -> 5
#   ##   ratio   --  output the ratio of successful attempts e.g. 37 -> 5/8 = 0.625
#   # reach_format = "octal"


# # Ping given url(s) and return statistics
# [[inputs.ping]]
#   ## Hosts to send ping packets to.
#   urls = ["example.org"]
#
#   ## Method used for sending pings, can be either "exec" or "native".  When set
#   ## to "exec" the systems ping command will be executed.  When set to "native"
#   ## the plugin will send pings directly.
#   ##
#   ## While the default is "exec" for backwards compatibility, new deployments
#   ## are encouraged to use the "native" method for improved compatibility and
#   ## performance.
#   # method = "exec"
#
#   ## Number of ping packets to send per interval.  Corresponds to the "-c"
#   ## option of the ping command.
#   # count = 1
#
#   ## Time to wait between sending ping packets in seconds.  Operates like the
#   ## "-i" option of the ping command.
#   # ping_interval = 1.0
#
#   ## If set, the time to wait for a ping response in seconds.  Operates like
#   ## the "-W" option of the ping command.
#   # timeout = 1.0
#
#   ## If set, the total ping deadline, in seconds.  Operates like the -w option
#   ## of the ping command.
#   # deadline = 10
#
#   ## Interface or source address to send ping from.  Operates like the -I or -S
#   ## option of the ping command.
#   # interface = ""
#
#   ## Percentiles to calculate. This only works with the native method.
#   # percentiles = [50, 95, 99]
#
#   ## Specify the ping executable binary.
#   # binary = "ping"
#
#   ## Arguments for ping command. When arguments is not empty, the command from
#   ## the binary option will be used and other options (ping_interval, timeout,
#   ## etc) will be ignored.
#   # arguments = ["-c", "3"]
#
#   ## Use only IPv4 addresses when resolving a hostname. By default, both IPv4
#   ## and IPv6 can be used.
#   # ipv4 = false
#
#   ## Use only IPv6 addresses when resolving a hostname. By default, both IPv4
#   ## and IPv6 can be used.
#   # ipv6 = false
#
#   ## Number of data bytes to be sent. Corresponds to the "-s"
#   ## option of the ping command. This only works with the native method.
#   # size = 56


# # Monitor process cpu and memory usage
# [[inputs.procstat]]
#   ## PID file to monitor process
#   pid_file = "/var/run/nginx.pid"
#   ## executable name (ie, pgrep <exe>)
#   # exe = "nginx"
#   ## pattern as argument for pgrep (ie, pgrep -f <pattern>)
#   # pattern = "nginx"
#   ## user as argument for pgrep (ie, pgrep -u <user>)
#   # user = "nginx"
#   ## Systemd unit name, supports globs when include_systemd_children is set to true
#   # systemd_unit = "nginx.service"
#   # include_systemd_children = false
#   ## CGroup name or path, supports globs
#   # cgroup = "systemd/system.slice/nginx.service"
#   ## Supervisor service names of hypervisorctl management
#   # supervisor_units = ["webserver", "proxy"]
#
#   ## Windows service name
#   # win_service = ""
#
#   ## override for process_name
#   ## This is optional; default is sourced from /proc/<pid>/status
#   # process_name = "bar"
#
#   ## Field name prefix
#   # prefix = ""
#
#   ## Mode to use when calculating CPU usage. Can be one of 'solaris' or 'irix'.
#   # mode = "irix"
#
#   ## Add the given information tag instead of a field
#   ## This allows to create unique metrics/series when collecting processes with
#   ## otherwise identical tags. However, please be careful as this can easily
#   ## result in a large number of series, especially with short-lived processes,
#   ## creating high cardinality at the output.
#   ## Available options are:
#   ##   cmdline   -- full commandline
#   ##   pid       -- ID of the process
#   ##   ppid      -- ID of the process' parent
#   ##   status    -- state of the process
#   ##   user      -- username owning the process
#   ## socket only options:
#   ##   protocol  -- protocol type of the process socket
#   ##   state     -- state of the process socket
#   ##   src       -- source address of the process socket (non-unix sockets)
#   ##   src_port  -- source port of the process socket (non-unix sockets)
#   ##   dest      -- destination address of the process socket (non-unix sockets)
#   ##   dest_port -- destination port of the process socket (non-unix sockets)
#   ##   name      -- name of the process socket (unix sockets only)
#   # tag_with = []
#
#   ## Properties to collect
#   ## Available options are
#   ##   cpu     -- CPU usage statistics
#   ##   limits  -- set resource limits
#   ##   memory  -- memory usage statistics
#   ##   mmap    -- mapped memory usage statistics (caution: can cause high load)
#   ##   sockets -- socket statistics for protocols in 'socket_protocols'
#   # properties = ["cpu", "limits", "memory", "mmap"]
#
#   ## Protocol filter for the sockets property
#   ## Available options are
#   ##   all  -- all of the protocols below
#   ##   tcp4 -- TCP socket statistics for IPv4
#   ##   tcp6 -- TCP socket statistics for IPv6
#   ##   udp4 -- UDP socket statistics for IPv4
#   ##   udp6 -- UDP socket statistics for IPv6
#   ##   unix -- Unix socket statistics
#   # socket_protocols = ["all"]
#
#   ## Method to use when finding process IDs.  Can be one of 'pgrep', or
#   ## 'native'.  The pgrep finder calls the pgrep executable in the PATH while
#   ## the native finder performs the search directly in a manor dependent on the
#   ## platform.  Default is 'pgrep'
#   # pid_finder = "pgrep"
#
#   ## New-style filtering configuration (multiple filter sections are allowed)
#   # [[inputs.procstat.filter]]
#   #    ## Name of the filter added as 'filter' tag
#   #    name = "shell"
#   #
#   #    ## Service filters, only one is allowed
#   #    ## Systemd unit names (wildcards are supported)
#   #    # systemd_units = []
#   #    ## CGroup name or path (wildcards are supported)
#   #    # cgroups = []
#   #    ## Supervisor service names of hypervisorctl management
#   #    # supervisor_units = []
#   #    ## Windows service names
#   #    # win_service = []
#   #
#   #    ## Process filters, multiple are allowed
#   #    ## Regular expressions to use for matching against the full command
#   #    # patterns = ['.*']
#   #    ## List of users owning the process (wildcards are supported)
#   #    # users = ['*']
#   #    ## List of executable paths of the process (wildcards are supported)
#   #    # executables = ['*']
#   #    ## List of process names (wildcards are supported)
#   #    # process_names = ['*']
#   #    ## Recursion depth for determining children of the matched processes
#   #    ## A negative value means all children with infinite depth
#   #    # recursion_depth = 0


# # Gather indicators from established connections, using iproute2's ss command.
# # This plugin ONLY supports non-Windows
# [[inputs.socketstat]]
#   ## ss can display information about tcp, udp, raw, unix, packet, dccp and sctp sockets
#   ## Specify here the types you want to gather
#   protocols = [ "tcp", "udp" ]
#
#   ## The default timeout of 1s for ss execution can be overridden here:
#   # timeout = "1s"


# # Sysstat metrics collector
# # This plugin ONLY supports Linux
# [[inputs.sysstat]]
#   ## Path to the sadc command.
#   #
#   ## Common Defaults:
#   ##   Debian/Ubuntu: /usr/lib/sysstat/sadc
#   ##   Arch:          /usr/lib/sa/sadc
#   ##   RHEL/CentOS:   /usr/lib64/sa/sadc
#   sadc_path = "/usr/lib/sa/sadc" # required
#
#   ## Path to the sadf command, if it is not in PATH
#   # sadf_path = "/usr/bin/sadf"
#
#   ## Activities is a list of activities, that are passed as argument to the
#   ## sadc collector utility (e.g: DISK, SNMP etc...)
#   ## The more activities that are added, the more data is collected.
#   # activities = ["DISK"]
#
#   ## Group metrics to measurements.
#   ##
#   ## If group is false each metric will be prefixed with a description
#   ## and represents itself a measurement.
#   ##
#   ## If Group is true, corresponding metrics are grouped to a single measurement.
#   # group = true
#
#   ## Options for the sadf command. The values on the left represent the sadf options and
#   ## the values on the right their description (which are used for grouping and prefixing metrics).
#   ##
#   ## Run 'sar -h' or 'man sar' to find out the supported options for your sysstat version.
#   [inputs.sysstat.options]
#     -C = "cpu"
#     -B = "paging"
#     -b = "io"
#     -d = "disk"             # requires DISK activity
#     "-n ALL" = "network"
#     "-P ALL" = "per_cpu"
#     -q = "queue"
#     -R = "mem"
#     -r = "mem_util"
#     -S = "swap_util"
#     -u = "cpu_util"
#     -v = "inode"
#     -W = "swap"
#     -w = "task"
#   # -H = "hugepages"        # only available for newer linux distributions
#   # "-I ALL" = "interrupts" # requires INT activity
#
#   ## Device tags can be used to add additional tags for devices. For example the configuration below
#   ## adds a tag vg with value rootvg for all metrics with sda devices.
#   # [[inputs.sysstat.device_tags.sda]]
#   #  vg = "rootvg"


# # Read metrics about temperature
# [[inputs.temp]]
#   ## Desired output format (Linux only)
#   ## Available values are
#   ##   v1 -- use pre-v1.22.4 sensor naming, e.g. coretemp_core0_input
#   ##   v2 -- use v1.22.4+ sensor naming, e.g. coretemp_core_0_input
#   # metric_format = "v2"
#
#   ## Add device tag to distinguish devices with the same name (Linux only)
#   # add_device_tag = false


# # Collect Wireguard server interface and peer statistics
# [[inputs.wireguard]]
#   ## Optional list of Wireguard device/interface names to query.
#   ## If omitted, all Wireguard interfaces are queried.
#   # devices = ["wg0"]


# # Monitor wifi signal strength and quality
# # This plugin ONLY supports Linux
# [[inputs.wireless]]
#   ## Sets 'proc' directory path
#   ## If not specified, then default is /proc
#   # host_proc = "/proc"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# # Read logging output from the Docker engine
# [[inputs.docker_log]]
#   ## Docker Endpoint
#   ##   To use TCP, set endpoint = "tcp://[ip]:[port]"
#   ##   To use environment variables (ie, docker-machine), set endpoint = "ENV"
#   # endpoint = "unix:///var/run/docker.sock"
#
#   ## When true, container logs are read from the beginning; otherwise reading
#   ## begins at the end of the log. If state-persistence is enabled for Telegraf,
#   ## the reading continues at the last previously processed timestamp.
#   # from_beginning = false
#
#   ## Timeout for Docker API calls.
#   # timeout = "5s"
#
#   ## Containers to include and exclude. Globs accepted.
#   ## Note that an empty array for both will include all containers
#   # container_name_include = []
#   # container_name_exclude = []
#
#   ## Container states to include and exclude. Globs accepted.
#   ## When empty only containers in the "running" state will be captured.
#   # container_state_include = []
#   # container_state_exclude = []
#
#   ## docker labels to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all labels as tags
#   # docker_label_include = []
#   # docker_label_exclude = []
#
#   ## Set the source tag for the metrics to the container ID hostname, eg first 12 chars
#   source_tag = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read formatted metrics from one or more HTTP endpoints
# [[inputs.http]]
#   ## One or more URLs from which to read formatted metrics.
#   urls = [
#     "http://localhost/metrics",
#     "http+unix:///run/user/420/podman/podman.sock:/d/v4.0.0/libpod/pods/json"
#   ]
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## HTTP entity-body to send with POST/PUT requests.
#   # body = ""
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## Optional Bearer token settings to use for the API calls.
#   ## Use either the token itself or the token file if you need a token.
#   # token = "eyJhbGc...Qssw5c"
#   # token_file = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## OAuth2 Client Credentials. The options 'client_id', 'client_secret', and 'token_url' are required to use OAuth2.
#   # client_id = "clientid"
#   # client_secret = "secret"
#   # token_url = "https://indentityprovider/oauth2/v1/token"
#   # scopes = ["urn:opc:idm:__myscopes__"]
#
#   ## HTTP Proxy support
#   # use_system_proxy = false
#   # http_proxy_url = ""
#
#   ## Optional TLS Config
#   ## Set to true/false to enforce TLS being enabled/disabled. If not set,
#   ## enable TLS only if any of the other options are specified.
#   # tls_enable =
#   ## Trusted root certificates for server
#   # tls_ca = "/path/to/cafile"
#   ## Used for TLS client certificate authentication
#   # tls_cert = "/path/to/certfile"
#   ## Used for TLS client certificate authentication
#   # tls_key = "/path/to/keyfile"
#   ## Password for the key file if it is encrypted
#   # tls_key_pwd = ""
#   ## Send the specified TLS server name via SNI
#   # tls_server_name = "kubernetes.example.com"
#   ## Minimal TLS version to accept by the client
#   # tls_min_version = "TLS12"
#   ## List of ciphers to accept, by default all secure ciphers will be accepted
#   ## See https://pkg.go.dev/crypto/tls#pkg-constants for supported values.
#   ## Use "all", "secure" and "insecure" to add all support ciphers, secure
#   ## suites or insecure suites respectively.
#   # tls_cipher_suites = ["secure"]
#   ## Renegotiation method, "never", "once" or "freely"
#   # tls_renegotiation_method = "never"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_headers = { Content-Type = "application/json", X-MY-HEADER = "hello" }
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## cookie_auth_renewal not set or set to "0" will auth once and never renew the cookie
#   # cookie_auth_renewal = "5m"
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"
#
#   ## List of success status codes
#   # success_status_codes = [200]
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"
#


# # Generic HTTP write listener
# [[inputs.http_listener_v2]]
#   ## Address to host HTTP listener on
#   ## can be prefixed by protocol tcp, or unix if not provided defaults to tcp
#   ## if unix network type provided it should be followed by absolute path for unix socket
#   service_address = "tcp://:8080"
#   ## service_address = "tcp://:8443"
#   ## service_address = "unix:///tmp/telegraf.sock"
#
#   ## Permission for unix sockets (only available for unix sockets)
#   ## This setting may not be respected by some platforms. To safely restrict
#   ## permissions it is recommended to place the socket into a previously
#   ## created directory with the desired permissions.
#   ##   ex: socket_mode = "777"
#   # socket_mode = ""
#
#   ## Paths to listen to.
#   # paths = ["/telegraf"]
#
#   ## Save path as http_listener_v2_path tag if set to true
#   # path_tag = false
#
#   ## HTTP methods to accept.
#   # methods = ["POST", "PUT"]
#
#   ## Optional HTTP headers
#   ## These headers are applied to the server that is listening for HTTP
#   ## requests and included in responses.
#   # http_headers = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## HTTP Return Success Code
#   ## This is the HTTP code that will be returned on success
#   # http_success_code = 204
#
#   ## maximum duration before timing out read of the request
#   # read_timeout = "10s"
#   ## maximum duration before timing out write of the response
#   # write_timeout = "10s"
#
#   ## Maximum allowed http request body size in bytes.
#   ## 0 means to use the default of 524,288,000 bytes (500 mebibytes)
#   # max_body_size = "500MB"
#
#   ## Part of the request to consume.  Available options are "body" and
#   ## "query".
#   # data_source = "body"
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Minimal TLS version accepted by the server
#   # tls_min_version = "TLS12"
#
#   ## Optional username and password to accept for HTTP basic authentication.
#   ## You probably want to make sure you have TLS configured above for this.
#   # basic_username = "foobar"
#   # basic_password = "barfoo"
#
#   ## Optional setting to map http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will be added
#   ## If multiple instances of the http header are present, only the first value will be used
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Accept metrics over InfluxDB 1.x HTTP API
# [[inputs.influxdb_listener]]
#   ## Address and port to host HTTP listener on
#   service_address = ":8186"
#
#   ## maximum duration before timing out read of the request
#   read_timeout = "10s"
#   ## maximum duration before timing out write of the response
#   write_timeout = "10s"
#
#   ## Maximum allowed HTTP request body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   max_body_size = 0
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Add service certificate and key
#   tls_cert = "/etc/telegraf/cert.pem"
#   tls_key = "/etc/telegraf/key.pem"
#
#   ## Optional tag name used to store the database name.
#   ## If the write has a database in the query string then it will be kept in this tag name.
#   ## This tag can be used in downstream outputs.
#   ## The default value of nothing means it will be off and the database will not be recorded.
#   ## If you have a tag that is the same as the one specified below, and supply a database,
#   ## the tag will be overwritten with the database supplied.
#   # database_tag = ""
#
#   ## If set the retention policy specified in the write query will be added as
#   ## the value of this tag name.
#   # retention_policy_tag = ""
#
#   ## Optional username and password to accept for HTTP basic authentication
#   ## or authentication token.
#   ## You probably want to make sure you have TLS configured above for this.
#   ## Use these options for the authentication token in the form
#   ##   Authentication: Token <basic_username>:<basic_password>
#   # basic_username = "foobar"
#   # basic_password = "barfoo"
#
#   ## Optional JWT token authentication for HTTP requests
#   ## Please see the documentation at
#   ##   https://docs.influxdata.com/influxdb/v1.8/administration/authentication_and_authorization/#authenticate-using-jwt-tokens
#   ## for further details.
#   ## Please note: Token authentication and basic authentication cannot be used
#   ##              at the same time.
#   # token_shared_secret = ""
#   # token_username = ""
#
#   ## Influx line protocol parser
#   ## 'internal' is the default. 'upstream' is a newer parser that is faster
#   ## and more memory efficient.
#   # parser_type = "internal"


# # Netflow v5, Netflow v9 and IPFIX collector
# [[inputs.netflow]]
#   ## Address to listen for netflow,ipfix or sflow packets.
#   ##   example: service_address = "udp://:2055"
#   ##            service_address = "udp4://:2055"
#   ##            service_address = "udp6://:2055"
#   service_address = "udp://:2055"
#
#   ## Set the size of the operating system's receive buffer.
#   ##   example: read_buffer_size = "64KiB"
#   ## Uses the system's default if not set.
#   # read_buffer_size = ""
#
#   ## Protocol version to use for decoding.
#   ## Available options are
#   ##   "ipfix"      -- IPFIX / Netflow v10 protocol (also works for Netflow v9)
#   ##   "netflow v5" -- Netflow v5 protocol
#   ##   "netflow v9" -- Netflow v9 protocol (also works for IPFIX)
#   ##   "sflow v5"   -- sFlow v5 protocol
#   # protocol = "ipfix"
#
#   ## Private Enterprise Numbers (PEN) mappings for decoding
#   ## This option allows to specify vendor-specific mapping files to use during
#   ## decoding.
#   # private_enterprise_number_files = []
#
#   ## Log incoming packets for tracing issues
#   # log_level = "trace"


# # Read metrics from one or many postgresql servers
# [[inputs.postgresql]]
#   ## Specify address via a url matching:
#   ##   postgres://[pqgotest[:password]]@localhost[/dbname]?sslmode=[disable|verify-ca|verify-full]&statement_timeout=...
#   ## or a simple string:
#   ##   host=localhost user=pqgotest password=... sslmode=... dbname=app_production
#   ## Users can pass the path to the socket as the host value to use a socket
#   ## connection (e.g. `/var/run/postgresql`).
#   ##
#   ## All connection parameters are optional.
#   ##
#   ## Without the dbname parameter, the driver will default to a database
#   ## with the same name as the user. This dbname is just for instantiating a
#   ## connection with the server and doesn't restrict the databases we are trying
#   ## to grab metrics for.
#   ##
#   address = "host=localhost user=postgres sslmode=disable"
#
#   ## A custom name for the database that will be used as the "server" tag in the
#   ## measurement output. If not specified, a default one generated from
#   ## the connection address is used.
#   # outputaddress = "db01"
#
#   ## connection configuration.
#   ## maxlifetime - specify the maximum lifetime of a connection.
#   ## default is forever (0s)
#   ##
#   ## Note that this does not interrupt queries, the lifetime will not be enforced
#   ## whilst a query is running
#   # max_lifetime = "0s"
#
#   ## A  list of databases to explicitly ignore.  If not specified, metrics for all
#   ## databases are gathered.  Do NOT use with the 'databases' option.
#   # ignored_databases = ["postgres", "template0", "template1"]
#
#   ## A list of databases to pull metrics about. If not specified, metrics for all
#   ## databases are gathered.  Do NOT use with the 'ignored_databases' option.
#   # databases = ["app_production", "testing"]
#
#   ## Whether to use prepared statements when connecting to the database.
#   ## This should be set to false when connecting through a PgBouncer instance
#   ## with pool_mode set to transaction.
#   prepared_statements = true


# # Read metrics from one or many postgresql servers
# [[inputs.postgresql_extensible]]
#   # specify address via a url matching:
#   # postgres://[pqgotest[:password]]@host:port[/dbname]?sslmode=...&statement_timeout=...
#   # or a simple string:
#   #   host=localhost port=5432 user=pqgotest password=... sslmode=... dbname=app_production
#   #
#   # All connection parameters are optional.
#   # Without the dbname parameter, the driver will default to a database
#   # with the same name as the user. This dbname is just for instantiating a
#   # connection with the server and doesn't restrict the databases we are trying
#   # to grab metrics for.
#   #
#   address = "host=localhost user=postgres sslmode=disable"
#
#   ## Whether to use prepared statements when connecting to the database.
#   ## This should be set to false when connecting through a PgBouncer instance
#   ## with pool_mode set to transaction.
#   prepared_statements = true
#
#   # Define the toml config where the sql queries are stored
#   # The script option can be used to specify the .sql file path.
#   # If script and sqlquery options specified at same time, sqlquery will be used
#   #
#   # the measurement field defines measurement name for metrics produced
#   # by the query. Default is "postgresql".
#   #
#   # the tagvalue field is used to define custom tags (separated by comas).
#   # the query is expected to return columns which match the names of the
#   # defined tags. The values in these columns must be of a string-type,
#   # a number-type or a blob-type.
#   #
#   # The timestamp field is used to override the data points timestamp value. By
#   # default, all rows inserted with current time. By setting a timestamp column,
#   # the row will be inserted with that column's value.
#   #
#   # The min_version field specifies minimal database version this query
#   # will run on.
#   #
#   # The max_version field when set specifies maximal database version
#   # this query will NOT run on.
#   #
#   # Database version in `minversion` and `maxversion` is represented as
#   # a single integer without last component, for example:
#   # 9.6.2 -> 906
#   # 15.2 -> 1500
#   #
#   # Structure :
#   # [[inputs.postgresql_extensible.query]]
#   #   measurement string
#   #   sqlquery string
#   #   min_version int
#   #   max_version int
#   #   withdbname boolean
#   #   tagvalue string (coma separated)
#   #   timestamp string
#   [[inputs.postgresql_extensible.query]]
#     measurement="pg_stat_database"
#     sqlquery="SELECT * FROM pg_stat_database WHERE datname"
#     min_version=901
#     tagvalue=""
#   [[inputs.postgresql_extensible.query]]
#     script="your_sql-filepath.sql"
#     min_version=901
#     max_version=1300
#     tagvalue=""


# # Generic socket listener capable of handling multiple socket types.
# [[inputs.socket_listener]]
#   ## URL to listen on
#   # service_address = "tcp://:8094"
#   # service_address = "tcp://127.0.0.1:http"
#   # service_address = "tcp4://:8094"
#   # service_address = "tcp6://:8094"
#   # service_address = "tcp6://[2001:db8::1]:8094"
#   # service_address = "udp://:8094"
#   # service_address = "udp4://:8094"
#   # service_address = "udp6://:8094"
#   # service_address = "unix:///tmp/telegraf.sock"
#   # service_address = "unixgram:///tmp/telegraf.sock"
#   # service_address = "vsock://cid:port"
#
#   ## Permission for unix sockets (only available on unix sockets)
#   ## This setting may not be respected by some platforms. To safely restrict
#   ## permissions it is recommended to place the socket into a previously
#   ## created directory with the desired permissions.
#   ##   ex: socket_mode = "777"
#   # socket_mode = ""
#
#   ## Maximum number of concurrent connections (only available on stream sockets like TCP)
#   ## Zero means unlimited.
#   # max_connections = 0
#
#   ## Read timeout (only available on stream sockets like TCP)
#   ## Zero means unlimited.
#   # read_timeout = "0s"
#
#   ## Optional TLS configuration (only available on stream sockets like TCP)
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key  = "/etc/telegraf/key.pem"
#   ## Enables client authentication if set.
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Maximum socket buffer size (in bytes when no unit specified)
#   ## For stream sockets, once the buffer fills up, the sender will start
#   ## backing up. For datagram sockets, once the buffer fills up, metrics will
#   ## start dropping. Defaults to the OS default.
#   # read_buffer_size = "64KiB"
#
#   ## Period between keep alive probes (only applies to TCP sockets)
#   ## Zero disables keep alive probes. Defaults to the OS configuration.
#   # keep_alive_period = "5m"
#
#   ## Content encoding for message payloads
#   ## Can be set to "gzip" for compressed payloads or "identity" for no encoding.
#   # content_encoding = "identity"
#
#   ## Maximum size of decoded packet (in bytes when no unit specified)
#   # max_decompression_size = "500MB"
#
#   ## Message splitting strategy and corresponding settings for stream sockets
#   ## (tcp, tcp4, tcp6, unix or unixpacket). The setting is ignored for packet
#   ## listeners such as udp.
#   ## Available strategies are:
#   ##   newline         -- split at newlines (default)
#   ##   null            -- split at null bytes
#   ##   delimiter       -- split at delimiter byte-sequence in hex-format
#   ##                      given in `splitting_delimiter`
#   ##   fixed length    -- split after number of bytes given in `splitting_length`
#   ##   variable length -- split depending on length information received in the
#   ##                      data. The length field information is specified in
#   ##                      `splitting_length_field`.
#   # splitting_strategy = "newline"
#
#   ## Delimiter used to split received data to messages consumed by the parser.
#   ## The delimiter is a hex byte-sequence marking the end of a message
#   ## e.g. "0x0D0A", "x0d0a" or "0d0a" marks a Windows line-break (CR LF).
#   ## The value is case-insensitive and can be specified with "0x" or "x" prefix
#   ## or without.
#   ## Note: This setting is only used for splitting_strategy = "delimiter".
#   # splitting_delimiter = ""
#
#   ## Fixed length of a message in bytes.
#   ## Note: This setting is only used for splitting_strategy = "fixed length".
#   # splitting_length = 0
#
#   ## Specification of the length field contained in the data to split messages
#   ## with variable length. The specification contains the following fields:
#   ##  offset        -- start of length field in bytes from begin of data
#   ##  bytes         -- length of length field in bytes
#   ##  endianness    -- endianness of the value, either "be" for big endian or
#   ##                   "le" for little endian
#   ##  header_length -- total length of header to be skipped when passing
#   ##                   data on to the parser. If zero (default), the header
#   ##                   is passed on to the parser together with the message.
#   ## Note: This setting is only used for splitting_strategy = "variable length".
#   # splitting_length_field = {offset = 0, bytes = 0, endianness = "be", header_length = 0}
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"


# # Read metrics from SQL queries
# [[inputs.sql]]
#   ## Database Driver
#   ## See https://github.com/influxdata/telegraf/blob/master/docs/SQL_DRIVERS_INPUT.md for
#   ## a list of supported drivers.
#   driver = "mysql"
#
#   ## Data source name for connecting
#   ## The syntax and supported options depends on selected driver.
#   dsn = "username:password@tcp(mysqlserver:3307)/dbname?param=value"
#
#   ## Timeout for any operation
#   ## Note that the timeout for queries is per query not per gather.
#   # timeout = "5s"
#
#   ## Connection time limits
#   ## By default the maximum idle time and maximum lifetime of a connection is unlimited, i.e. the connections
#   ## will not be closed automatically. If you specify a positive time, the connections will be closed after
#   ## idleing or existing for at least that amount of time, respectively.
#   # connection_max_idle_time = "0s"
#   # connection_max_life_time = "0s"
#
#   ## Connection count limits
#   ## By default the number of open connections is not limited and the number of maximum idle connections
#   ## will be inferred from the number of queries specified. If you specify a positive number for any of the
#   ## two options, connections will be closed when reaching the specified limit. The number of idle connections
#   ## will be clipped to the maximum number of connections limit if any.
#   # connection_max_open = 0
#   # connection_max_idle = auto
#
#   ## Specifies plugin behavior regarding disconnected servers
#   ## Available choices :
#   ##   - error: telegraf will return an error on startup if one the servers is unreachable
#   ##   - ignore: telegraf will ignore unreachable servers on both startup and gather
#   # disconnected_servers_behavior = "error"
#
#   [[inputs.sql.query]]
#     ## Query to perform on the server
#     query="SELECT user,state,latency,score FROM Scoreboard WHERE application > 0"
#     ## Alternatively to specifying the query directly you can select a file here containing the SQL query.
#     ## Only one of 'query' and 'query_script' can be specified!
#     # query_script = "/path/to/sql/script.sql"
#
#     ## Name of the measurement
#     ## In case both measurement and 'measurement_col' are given, the latter takes precedence.
#     # measurement = "sql"
#
#     ## Column name containing the name of the measurement
#     ## If given, this will take precedence over the 'measurement' setting. In case a query result
#     ## does not contain the specified column, we fall-back to the 'measurement' setting.
#     # measurement_column = ""
#
#     ## Column name containing the time of the measurement
#     ## If omitted, the time of the query will be used.
#     # time_column = ""
#
#     ## Format of the time contained in 'time_col'
#     ## The time must be 'unix', 'unix_ms', 'unix_us', 'unix_ns', or a golang time format.
#     ## See https://golang.org/pkg/time/#Time.Format for details.
#     # time_format = "unix"
#
#     ## Column names containing tags
#     ## An empty include list will reject all columns and an empty exclude list will not exclude any column.
#     ## I.e. by default no columns will be returned as tag and the tags are empty.
#     # tag_columns_include = []
#     # tag_columns_exclude = []
#
#     ## Column names containing fields (explicit types)
#     ## Convert the given columns to the corresponding type. Explicit type conversions take precedence over
#     ## the automatic (driver-based) conversion below.
#     ## NOTE: Columns should not be specified for multiple types or the resulting type is undefined.
#     # field_columns_float = []
#     # field_columns_int = []
#     # field_columns_uint = []
#     # field_columns_bool = []
#     # field_columns_string = []
#
#     ## Column names containing fields (automatic types)
#     ## An empty include list is equivalent to '[*]' and all returned columns will be accepted. An empty
#     ## exclude list will not exclude any column. I.e. by default all columns will be returned as fields.
#     ## NOTE: We rely on the database driver to perform automatic datatype conversion.
#     # field_columns_include = []
#     # field_columns_exclude = []


# [[inputs.syslog]]
#   ## Protocol, address and port to host the syslog receiver.
#   ## If no host is specified, then localhost is used.
#   ## If no port is specified, 6514 is used (RFC5425#section-4.1).
#   ##   ex: server = "tcp://localhost:6514"
#   ##       server = "udp://:6514"
#   ##       server = "unix:///var/run/telegraf-syslog.sock"
#   ## When using tcp, consider using 'tcp4' or 'tcp6' to force the usage of IPv4
#   ## or IPV6 respectively. There are cases, where when not specified, a system
#   ## may force an IPv4 mapped IPv6 address.
#   server = "tcp://127.0.0.1:6514"
#
#   ## Permission for unix sockets (only available on unix sockets)
#   ## This setting may not be respected by some platforms. To safely restrict
#   ## permissions it is recommended to place the socket into a previously
#   ## created directory with the desired permissions.
#   ##   ex: socket_mode = "777"
#   # socket_mode = ""
#
#   ## Maximum number of concurrent connections (only available on stream sockets like TCP)
#   ## Zero means unlimited.
#   # max_connections = 0
#
#   ## Read timeout (only available on stream sockets like TCP)
#   ## Zero means unlimited.
#   # read_timeout = "0s"
#
#   ## Optional TLS configuration (only available on stream sockets like TCP)
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key  = "/etc/telegraf/key.pem"
#   ## Enables client authentication if set.
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Maximum socket buffer size (in bytes when no unit specified)
#   ## For stream sockets, once the buffer fills up, the sender will start
#   ## backing up. For datagram sockets, once the buffer fills up, metrics will
#   ## start dropping. Defaults to the OS default.
#   # read_buffer_size = "64KiB"
#
#   ## Period between keep alive probes (only applies to TCP sockets)
#   ## Zero disables keep alive probes. Defaults to the OS configuration.
#   # keep_alive_period = "5m"
#
#   ## Content encoding for message payloads
#   ## Can be set to "gzip" for compressed payloads or "identity" for no encoding.
#   # content_encoding = "identity"
#
#   ## Maximum size of decoded packet (in bytes when no unit specified)
#   # max_decompression_size = "500MB"
#
#   ## Framing technique used for messages transport
#   ## Available settings are:
#   ##   octet-counting  -- see RFC5425#section-4.3.1 and RFC6587#section-3.4.1
#   ##   non-transparent -- see RFC6587#section-3.4.2
#   # framing = "octet-counting"
#
#   ## The trailer to be expected in case of non-transparent framing (default = "LF").
#   ## Must be one of "LF", or "NUL".
#   # trailer = "LF"
#
#   ## Whether to parse in best effort mode or not (default = false).
#   ## By default best effort parsing is off.
#   # best_effort = false
#
#   ## The RFC standard to use for message parsing
#   ## By default RFC5424 is used. RFC3164 only supports UDP transport (no streaming support)
#   ## Must be one of "RFC5424", or "RFC3164".
#   # syslog_standard = "RFC5424"
#
#   ## Character to prepend to SD-PARAMs (default = "_").
#   ## A syslog message can contain multiple parameters and multiple identifiers within structured data section.
#   ## Eg., [id1 name1="val1" name2="val2"][id2 name1="val1" nameA="valA"]
#   ## For each combination a field is created.
#   ## Its name is created concatenating identifier, sdparam_separator, and parameter name.
#   # sdparam_separator = "_"


# # Parse the new lines appended to a file
# [[inputs.tail]]
#   ## File names or a pattern to tail.
#   ## These accept standard unix glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   "/var/log/**.log"  -> recursively find all .log files in /var/log
#   ##   "/var/log/*/*.log" -> find all .log files with a parent dir in /var/log
#   ##   "/var/log/apache.log" -> just tail the apache log file
#   ##   "/var/log/log[!1-2]*  -> tail files without 1-2
#   ##   "/var/log/log[^1-2]*  -> identical behavior as above
#   ## See https://github.com/gobwas/glob for more examples
#   ##
#   files = ["/var/mymetrics.out"]
#
#   ## Read file from beginning.
#   # from_beginning = false
#
#   ## Whether file is a named pipe
#   # pipe = false
#
#   ## Method used to watch for file updates.  Can be either "inotify" or "poll".
#   ## inotify is supported on linux, *bsd, and macOS, while Windows requires
#   ## using poll. Poll checks for changes every 250ms.
#   # watch_method = "inotify"
#
#   ## Maximum lines of the file to process that have not yet be written by the
#   ## output.  For best throughput set based on the number of metrics on each
#   ## line and the size of the output's metric_batch_size.
#   # max_undelivered_lines = 1000
#
#   ## Character encoding to use when interpreting the file contents.  Invalid
#   ## characters are replaced using the unicode replacement character.  When set
#   ## to the empty string the data is not decoded to text.
#   ##   ex: character_encoding = "utf-8"
#   ##       character_encoding = "utf-16le"
#   ##       character_encoding = "utf-16be"
#   ##       character_encoding = ""
#   # character_encoding = ""
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#
#   ## Set the tag that will contain the path of the tailed file. If you don't want this tag, set it to an empty string.
#   # path_tag = "path"
#
#   ## Filters to apply to files before generating metrics
#   ## "ansi_color" removes ANSI colors
#   # filters = []
#
#   ## multiline parser/codec
#   ## https://www.elastic.co/guide/en/logstash/2.4/plugins-filters-multiline.html
#   #[inputs.tail.multiline]
#     ## The pattern should be a regexp which matches what you believe to be an indicator that the field is part of an event consisting of multiple lines of log data.
#     #pattern = "^\s"
#
#     ## The field's value must be previous or next and indicates the relation to the
#     ## multi-line event.
#     #match_which_line = "previous"
#
#     ## The invert_match can be true or false (defaults to false).
#     ## If true, a message not matching the pattern will constitute a match of the multiline filter and the what will be applied. (vice-versa is also true)
#     #invert_match = false
#
#     ## The handling method for quoted text (defaults to 'ignore').
#     ## The following methods are available:
#     ##   ignore  -- do not consider quotation (default)
#     ##   single-quotes -- consider text quoted by single quotes (')
#     ##   double-quotes -- consider text quoted by double quotes (")
#     ##   backticks     -- consider text quoted by backticks (`)
#     ## When handling quotes, escaped quotes (e.g. \") are handled correctly.
#     #quotation = "ignore"
#
#     ## The preserve_newline option can be true or false (defaults to false).
#     ## If true, the newline character is preserved for multiline elements,
#     ## this is useful to preserve message-structure e.g. for logging outputs.
#     #preserve_newline = false
#
#     #After the specified timeout, this plugin sends the multiline event even if no new pattern is found to start a new event. The default is 5s.
#     #timeout = 5s

